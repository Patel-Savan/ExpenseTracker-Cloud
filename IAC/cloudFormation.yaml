AWSTemplateFormatVersion: "2010-09-09"

Resources:

# Notification Topic
  TermProjectNotificationTopic:
    Type: AWS::SNS::Topic
    Properties:
      DisplayName: Term-Project-CSCI5409
      TopicName: CSCI5409-Term-Project-Notification-Topic

# Register User Lambda function
  TermProjectRegisterUser:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: "Term-Project-Register-User"
      Handler: "index.handler"
      Role: YourRoleArn
      Runtime: "nodejs20.x"
      Timeout: 20
      Environment:
        Variables:
          SNS_ARN: !Ref TermProjectNotificationTopic
      Code: 
        ZipFile: |
          const { DynamoDBDocument } = require("@aws-sdk/lib-dynamodb");
          const { DynamoDB } = require("@aws-sdk/client-dynamodb");
          const { SNSClient, SubscribeCommand, PublishCommand } = require("@aws-sdk/client-sns");
          const crypto = require("crypto");

          const dynamoDB = DynamoDBDocument.from(new DynamoDB({ region: "us-east-1" }));
          const sns = new SNSClient({ region: "us-east-1" });

          const tableName = "Term-Project-Application-Users";

          exports.handler = async (event) => {
            const body = JSON.parse(event.body);
            const name = body.username;
            const email = body.useremail.toLowerCase();
            const password = body.userpassword;
            const income = body.income;

            if (!name || !email || !password || !income) {
              return buildResponse(400, "All the fields are required");
            }

            const dbUser = await getUser(email);

            if (dbUser && dbUser.useremail) {
              if(dbUser.isSubscribed)
                  return buildResponse(400, "User already exist with this email");

              await deleteUser(email);
            }

            const encryptPassword = crypto
              .createHash("sha256")
              .update(password)
              .digest("hex");

            try {
              const subscribeParams = {
                Protocol: "email",
                TopicArn: process.env.SNS_ARN,
                Endpoint: email,
                Attributes: {'FilterPolicy': JSON.stringify({'email': [email]})}
              };

              await sns.send(new SubscribeCommand(subscribeParams));

              const user = {
                useremail: email,
                username: name,
                password: encryptPassword,
                income: income,
                isSubscribed: false
              };

              await saveUser(user);

              return buildResponse(
                200,
                "User registered successfully. Please check your email and subscribe to get the Expense Reports."
              );
            } catch (error) {
              console.error("Error registering user:", error);
              return buildResponse(500, "Server Error while saving user to database");
            }
          };

          const buildResponse = (statusCode, message) => {
            const response = {
              statusCode: statusCode,
              headers: {
                "Access-Control-Allow-Origin": "*",
                "Content-type": "application/json"
              },
              body: JSON.stringify(message)
            };

            return response;
          };

          const getUser = async (useremail) => {
            const params = {
              TableName: tableName,
              Key: {
                useremail: useremail
              }
            };

            return await dynamoDB.get(params).then(
              (response) => {
                return response.Item;
              },
              (error) => {
                return error.message;
              }
            );
          };

          const saveUser = async (user) => {
            const params = {
              TableName: tableName,
              Item: user
            };
            return await dynamoDB.put(params).then(
              (response) => {
                return true;
              },
              (error) => {
                throw error;
              }
            );
          };

          const deleteUser = async (useremail) => {
            const params = {
              TableName: tableName,
              Key: {
                useremail: useremail
              }
            };

            await dynamoDB.delete(params);
          };

# Login Lambda Function
  TermProjectLoginUser:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: "Term-Project-Login-User"
      Handler: "index.handler"
      Role: YourRoleArn
      Runtime: "nodejs20.x"
      Timeout: 20
      Environment:
        Variables:
          SNS_ARN: !Ref TermProjectNotificationTopic
      Code:
        ZipFile: | 
          const { DynamoDBDocument } = require("@aws-sdk/lib-dynamodb");
          const { DynamoDB } = require("@aws-sdk/client-dynamodb");
          const { SNSClient, PublishCommand, ListSubscriptionsByTopicCommand } = require("@aws-sdk/client-sns");
          const crypto = require("crypto");

          const dynamoDb = DynamoDBDocument.from(
            new DynamoDB({
              region: "us-east-1"
            })
          );
          const sns = new SNSClient({ region: "us-east-1" });

          const tableName = "Term-Project-Application-Users";

          const handler = async (event) => {
            const body = JSON.parse(event.body);
            var email = body.useremail.toLowerCase();
            var password = body.userpassword;

            if (!email || !password) {
              return buildResponse(400, "Username and Password are Required");
            }

            const dbUser = await getUser(email);

            if (!dbUser || !dbUser.useremail) {
              return buildResponse(403, "Account does not exist for this email");
            }

            const encryptPassword = crypto
              .createHash("sha256")
              .update(password)
              .digest("hex");

            if (encryptPassword != dbUser.password) {
              return buildResponse(403, "Password is incorrect");
            }

            try {
              console.log("Starting try block");
              if (!dbUser.isSubscribed) {
                console.log("Getting Subscription");
                const subArn = await findSubscriptionArnByEmail(email);
                if (subArn == "PendingConfirmation") {
                  return buildResponse(
                    403,
                    "Confirm the Subscription from your email first."
                  );
                } else {
                  await updateUser(email);
                }
              }

              console.log("Sending Notification");
              await sendNotification(
                email,
                "You have Successfully Logges in to the Expense Tracker",
                "Login Confirmation."
              );

              const userInfo = {
                name: dbUser.username,
                email: dbUser.useremail
              };

              return buildResponse(200, userInfo);
            } catch (error) {
              console.log(error.message);
              return buildResponse(500, "Internal Server Error");
            }
          };

          const getUser = async (userEmail) => {
            const params = {
              TableName: tableName,
              Key: {
                useremail: userEmail
              }
            };

            return await dynamoDb.get(params).then(
              (response) => {
                return response.Item;
              },
              (error) => {
                console.log(error);
                error.message;
              }
            );
          };

          const sendNotification = async (email, message, subject) => {
            try {
              await sns.send(
                new PublishCommand({
                  Message: message,
                  Subject: subject,
                  TargetArn: process.env.SNS_ARN,
                  MessageAttributes: {
                    email: {
                      DataType: "String",
                      StringValue: email
                    }
                  }
                })
              );
            } catch (error) {
              console.log(error.message);
              throw Error(error.message);
            }
          };

          const buildResponse = (statusCode, message) => {
            const Response = {
              statusCode: statusCode,
              headers: {
                "Access-Control-Allow-Origin": "*",
                "Content-type": "application/json"
              },
              body: JSON.stringify(message)
            };

            return Response;
          };

          const findSubscriptionArnByEmail = async (email) => {
            try {
              console.log(process.env.SNS_ARN);
              console.log("Inside Find Subscription Method");

              const data = await sns.send(
                new ListSubscriptionsByTopicCommand({ TopicArn: process.env.SNS_ARN })
              );

              console.log(data);
              const subscription = data.Subscriptions.find(
                (sub) => sub.Endpoint === email
              );

              console.log(subscription);
              if (subscription) {
                return subscription.SubscriptionArn;
              } else {
                return null;
              }
            } catch (error) {
              console.log(error.message);
              throw Error("Error while getting Subscription");
            }
          };

          const updateUser = async (email) => {
            const params = {
              TableName: tableName,
              Key: {
                useremail: email
              },
              UpdateExpression: "set #attrName = :attrValue",
              ExpressionAttributeNames: {
                "#attrName": "isSubscribed"
              },
              ExpressionAttributeValues: {
                ":attrValue": true
              },
              ReturnValues: "ALL_NEW"
            };

            return await dynamoDb.update(params).then(
              (response) => {
                const res = {
                  statusCode: 200,
                  updatedItem: response.Item
                };
                return res;
              },
              (error) => {
                console.log(error);
                throw Error("Cannot Update Subscription");
              }
            );
          };

          module.exports = { handler };

# Reset Password Lambda function
  TermProjectResetPassword:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: "Term-Project-Reset-Password"
      Handler: "index.handler"
      Role: YourRoleArn
      Runtime: "nodejs20.x"
      Timeout: 20
      Environment:
        Variables:
          SNS_ARN: !Ref TermProjectNotificationTopic
      Code:
        ZipFile: |
          const { DynamoDBDocument } = require("@aws-sdk/lib-dynamodb");
          const { DynamoDB } = require("@aws-sdk/client-dynamodb");
          const { SNSClient, PublishCommand } = require("@aws-sdk/client-sns");

          const sns = new SNSClient({ region: "us-east-1" });
          const dynamoDB = DynamoDBDocument.from(new DynamoDB({ region: "us-east-1" }));
          const userTable = "Term-Project-Application-Users";
          const resetPasswordTable = "Term-Project-Reset-Password-Code";

          const handler = async (event) => {
            try {
              const body = JSON.parse(event.body);
              const email = body.useremail.toLowerCase();

              if (!email) {
                return buildResponse(400, "Email is required");
              }

              const dbUser = await getUser(email);

              if (!dbUser || !dbUser.useremail) {
                return buildResponse(403, "Account does not exist for this email");
              }

              if (!dbUser.isSubscribed) {
                return buildResponse(403, "Please Confirm Subscription First");
              }

              let randomNumber = "";
              for (let i = 0; i < 6; i++) {
                randomNumber += Math.floor(Math.random() * 10).toString();
              }

              await sendCode(email, "Code for Resetting Password", randomNumber);

              await saveCode(email, randomNumber);

              const userInfo = {
                email: email
              }
              return buildResponse(200, userInfo);
            } catch (error) {
              console.error("Error updating user details:", error);
              return buildResponse(500, "Server error while updating user details");
            }
          };

          const buildResponse = (statusCode, message) => {
            return {
              statusCode: statusCode,
              headers: {
                "Access-Control-Allow-Origin": "*",
                "Content-Type": "application/json"
              },
              body: JSON.stringify(message)
            };
          };

          const getUser = async (userEmail) => {
            const params = {
              TableName: userTable,
              Key: {
                useremail: userEmail
              }
            };

            return await dynamoDB.get(params).then(
              (response) => {
                return response.Item;
              },
              (error) => {
                console.log(error);
                error.message;
              }
            );
          };

          const sendCode = async (useremail, subject, code) => {
            try {
              const message = `Use this Code for Resetting Password: ${code}`;
              await sns.send(
                new PublishCommand({
                  Message: message,
                  Subject: subject,
                  TargetArn: process.env.SNS_ARN,
                  MessageAttributes: {
                    email: {
                      DataType: "String",
                      StringValue: useremail
                    }
                  }
                })
              );
            } catch (error) {
              console.log(error.message);
              throw Error(error.message);
            }
          };

          const saveCode = async (useremail, code) => {
            const params = {
              TableName: resetPasswordTable,
              Item: {
                useremail: useremail,
                code: code
              }
            };

            await dynamoDB.put(params).then(
              (response) => {
                return true;
              },
              (error) => {
                console.log(error);
                throw Error("Cannot Save Code");
              }
            );
          };

          module.exports = { handler };

# Change Password Lambda function
  TermProjectChangePassword:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: "Term-Project-Change-Password"
      Handler: "index.handler"
      Role: YourRoleArn
      Runtime: "nodejs20.x"
      Timeout: 20
      Environment:
        Variables:
          SNS_ARN: !Ref TermProjectNotificationTopic
      Code:
        ZipFile: |
          const { DynamoDBDocument, DeleteCommand } = require("@aws-sdk/lib-dynamodb");
          const { DynamoDB } = require("@aws-sdk/client-dynamodb");
          const { SNSClient, PublishCommand } = require("@aws-sdk/client-sns");
          const crypto = require("crypto");

          const sns = new SNSClient({ region: "us-east-1" });
          const dynamoDB = DynamoDBDocument.from(new DynamoDB({ region: "us-east-1" }));
          const userTable = "Term-Project-Application-Users";
          const resetPasswordTable = "Term-Project-Reset-Password-Code";

          const handler = async (event) => {
            try {
              const body = JSON.parse(event.body);

              const useremail = body.useremail;
              const password = body.userpassword;
              const code = body.verificationCode;

              const codeMatches = await verifyCode(useremail, code);

              if (!codeMatches) {
                return buildResponse(403, "Password Reset Code does not match");
              }

              const encryptPassword = crypto
                .createHash("sha256")
                .update(password)
                .digest("hex");

              await changePassword(useremail, encryptPassword);

              await deleteCode(useremail);

              await sendNotification(
                useremail,
                "Password Changed Successfully",
                `You have successfully changed the password on Expense Tracker for email ${useremail}`
              );
              return buildResponse(200, "Password Changed Successfully");
            } catch (error) {
              console.log(error);
              return buildResponse(500, "Server Error changing Password");
            }
          };

          const buildResponse = (statusCode, message) => {
            const response = {
              statusCode: statusCode,
              headers: {
                "Access-Control-Allow-Origin": "*",
                "Content-type": "application/json"
              },
              body: JSON.stringify(message)
            };

            return response;
          };

          const deleteCode = async (useremail) => {
            const params = {
              TableName: resetPasswordTable,
              Key: {
                useremail: useremail
              }
            };

            const command = new DeleteCommand(params);

            try {
              const result = await dynamoDB.send(command);
              return result;
            } catch (error) {
              console.error(error);
              throw Error("Error deleting User");
            }
          };

          const verifyCode = async (useremail, code) => {
            const params = {
              TableName: resetPasswordTable,
              Key: {
                useremail: useremail
              }
            };
            let storedCode;
            await dynamoDB.get(params).then(
              (response) => {
                console.log(response);
                storedCode = response.Item.code;
              },
              (error) => {
                console.log(error);
                throw Error("Error checking Code");
              }
            );

            console.log(code);
            console.log(storedCode);
            return code === storedCode;
          };

          const changePassword = async (useremail, password) => {
            const params = {
              TableName: userTable,
              Key: {
                useremail: useremail
              },
              UpdateExpression: "set #attrName = :attrValue",
              ExpressionAttributeNames: {
                "#attrName": "password"
              },
              ExpressionAttributeValues: {
                ":attrValue": password
              },
              ReturnValues: "ALL_NEW"
            };

            return await dynamoDB.update(params).then(
              (response) => {
                return response;
              },
              (error) => {
                console.log(error);
                throw Error("Error changing password");
              }
            );
          };

          const sendNotification = async (email, subject, message) => {
            try {
              await sns.send(
                new PublishCommand({
                  TopicArn: process.env.SNS_ARN,
                  Message: message,
                  Subject: subject,
                  MessageAttributes: {
                    email: {
                      DataType: "String",
                      StringValue: email
                    }
                  }
                })
              );
            } catch (error) {
              console.log(error.message);
            }
          };

          module.exports = { handler };

# Add Expense Lambda function
  TermProjectAddExpense:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: "Term-Project-Add-Expense"
      Handler: "index.handler"
      Role: YourRoleArn
      Runtime: "nodejs20.x"
      Timeout: 20
      Environment:
        Variables:
          SNS_ARN: !Ref TermProjectNotificationTopic
      Code:
        ZipFile: | 
          const { DynamoDBDocument } = require("@aws-sdk/lib-dynamodb");
          const { DynamoDB } = require("@aws-sdk/client-dynamodb");
          const { TextractClient, AnalyzeDocumentCommand } = require("@aws-sdk/client-textract");
          const { S3Client, PutObjectCommand } = require("@aws-sdk/client-s3");
          const { SNSClient, PublishCommand } = require("@aws-sdk/client-sns");

          const dynamoDB = DynamoDBDocument.from(new DynamoDB({ region: "us-east-1" }));
          const textract = new TextractClient({ region: "us-east-1" });
          const s3 = new S3Client({ region: "us-east-1" });
          const sns = new SNSClient({ region: "us-east-1" });

          const tableName = "Term-Project-Expense-Table";
          const bucketName = "term-project-expense-tracker-bucket";

          const handler = async (event) => {
            try {
              const body = JSON.parse(event.body);
              let { useremail, expenseName, imageBase64, expenseAmount } = body;

              const monthKey = new Date().toISOString().slice(0, 7);

              if (!expenseAmount && !imageBase64) {
                return buildResponse(400, "Any one of expense amount or bill image is required");
              }
              if (!useremail || !expenseName) {
                return buildResponse(400, "Email and expense name are required");
              }

              let imageBuffer, s3Key, encodedEmail, imageUrl = "";

              if (imageBase64) {
                imageBuffer = Buffer.from(imageBase64, "base64");
                s3Key = `${useremail}/${monthKey}/${expenseName}.jpg`;

                encodedEmail = encodeURIComponent(useremail);
                imageUrl = `https://${bucketName}.s3.us-east-1.amazonaws.com/${encodedEmail}/${monthKey}/${expenseName}.jpg`;
                console.log("Inside upload image");
                await uploadImageToS3(imageBuffer, s3Key);
              }

              const dbItem = await getExpense(useremail);
              if (!dbItem || !dbItem.useremail) {
                await addExpense(useremail);
              }

              if (!expenseAmount) {
                const textractResponse = await analyzeDocument(imageBuffer);

                console.log("Inside extract amount");
                const extractedExpense = extractExpenseDetails(textractResponse);
                if (!extractedExpense) {
                  return buildResponse(400, "Failed to extract expense details.");
                }

                expenseAmount = extractedExpense;
              }

              const expenseDetails = {
                expenseName: expenseName,
                amount: expenseAmount,
                expenseImageUrl: imageUrl
              };

              await updateExpense(useremail, monthKey, expenseDetails);

              const message = `Expense ${expenseAmount} has been added for ${expenseName} to your Expense tracker.`;
              await sendNotification(useremail, message, "Expense Added");

              return buildResponse(200, "Expense added successfully.");
            } catch (error) {
              console.error("Error processing expense:", error);
              return buildResponse(500, "Server error while processing expense.");
            }
          };

          const sendNotification = async (email, message, subject) => {
            try {
              await sns.send(
                new PublishCommand({
                  Message: message,
                  Subject: subject,
                  TargetArn: process.env.SNS_ARN,
                  MessageAttributes: {
                    email: {
                      DataType: "String",
                      StringValue: email
                    }
                  }
                })
              );
            } catch (error) {
              console.log(error.message);
              throw Error(error.message);
            }
          };

          const uploadImageToS3 = async (imageBuffer, key) => {
            try {
              const params = {
                Bucket: bucketName,
                Key: key,
                Body: imageBuffer,
                ContentType: "image/jpeg"
              };
              const command = new PutObjectCommand(params);
              await s3.send(command);
            } catch (error) {
              console.log(error);
              throw Error("Error uploading image to S3");
            }
          };

          const analyzeDocument = async (imageBuffer) => {
            const params = {
              Document: { Bytes: imageBuffer },
              FeatureTypes: ["TABLES", "FORMS"]
            };
            const command = new AnalyzeDocumentCommand(params);
            const response = await textract.send(command);
            return response;
          };

          const extractExpenseDetails = (textractResponse) => {
            let totalAmount = null;

            let blocks = textractResponse.Blocks;
            for (let i = 0; i < blocks.length; i++) {
              const block = blocks[i];
              if (block.BlockType === "LINE") {
                const text = block.Text;
                console.log(text);

                const totalRegex = /^Total\s*:?\s*$/i;

                if (totalRegex.test(text)) {
                  i++;
                  while (blocks[i].BlockType != "LINE") {
                    console.log(blocks[i]);
                    i++;
                  }
                  const currentBlock = blocks[i].Text;
                  console.log(currentBlock);
                  if (currentBlock.includes("$")) {
                    totalAmount = currentBlock.replace(/^\$/, "");
                    console.log("Inside last if");
                    console.log(totalAmount);
                  } else {
                    totalAmount = currentBlock;
                  }
                  if (totalAmount) {
                    break;
                  }
                }
              }
            }

            if (!totalAmount) {
              throw new Error("Failed to extract the total amount from the document.");
            }

            return totalAmount;
          };

          const addExpense = async (useremail) => {
            const params = {
              TableName: tableName,
              Item: {
                useremail: useremail,
                expenses: {}
              }
            };
            return await dynamoDB.put(params).then(
              (response) => {
                return true;
              },
              (error) => {
                console.log(error);
                throw Error("Error while adding new Expense");
              }
            );
          };

          const getExpense = async (userEmail) => {
            const params = {
              TableName: tableName,
              Key: {
                useremail: userEmail
              }
            };

            return await dynamoDB.get(params).then(
              (response) => {
                return response.Item;
              },
              (error) => {
                console.log(error);
                throw Error("Error while getting Expense details");
              }
            );
          };

          const updateExpense = async (userEmail, monthKey, expense) => {
            const params = {
              TableName: tableName,
              Key: { useremail: userEmail },
              UpdateExpression: `SET expenses.#monthKey = list_append(if_not_exists(expenses.#monthKey, :emptyList), :expense)`,
              ExpressionAttributeNames: {
                "#monthKey": monthKey
              },
              ExpressionAttributeValues: {
                ":expense": [expense],
                ":emptyList": []
              }
            };

            return await dynamoDB.update(params).then(
              (response) => {
                return true;
              },
              (error) => {
                console.log(error);
                throw Error("Error while updating expense list");
              }
            );
          };

          const buildResponse = (statusCode, message) => {
            return {
              statusCode: statusCode,
              headers: {
                "Access-Control-Allow-Origin": "*",
                "Content-Type": "application/json"
              },
              body: JSON.stringify({ message })
            };
          };

          module.exports = { handler };

# Get Current Month Expense Lambda function
  TermProjectGetCurrentMonthExpense:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: "Term-Project-Current-Month-Expense"
      Handler: "index.handler"
      Role: YourRoleArn
      Runtime: "nodejs20.x"
      Timeout: 20
      Code:
        ZipFile: | 
          const { DynamoDBDocument } = require("@aws-sdk/lib-dynamodb");
          const { DynamoDB } = require("@aws-sdk/client-dynamodb");

          const dynamoDB = DynamoDBDocument.from(new DynamoDB({ region: "us-east-1" }));

          const tableName = "Term-Project-Expense-Table";

          exports.handler = async (event) => {
          try {
            const body = JSON.parse(event.body);
            const email = body.useremail;

            const userDetails = await getUserDetails(email);

            if (!userDetails) {
              return buildResponse(200, "You have not added any expense");
            }

            const monthKey = new Date().toISOString().slice(0, 7);
            const expenseList = userDetails.expenses[monthKey];
            console.log(userDetails.expenses);
            console.log(expenseList);
            if (!expenseList) {
              return buildResponse(200, "You have not added any expenses this month");
            }

            const responseBody = {
              message: "Successfully Obtained Current Month Expense",
              expenseList: expenseList
            };
            return buildResponse(200, responseBody);
          } catch (error) {
            console.error("Error sending reports:", error);
            return buildResponse(500, "Server error while sending reports.");
          }
          };

          const getUserDetails = async (email) => {
          const params = {
            TableName: tableName,
            Key: {
              useremail: email
            }
          };

          try {
            const response = await dynamoDB.get(params);
            console.log(response);
            return response.Item;
          } catch (error) {
            console.log(error);
            throw new Error("Error getting User details");
          }
          };

          const buildResponse = (statusCode, message) => {
          return {
            statusCode: statusCode,
            headers: {
              "Access-Control-Allow-Origin": "*",
              "Content-Type": "application/json"
            },
            body: JSON.stringify(message)
          };
          };

# Get Previous Month Expenses Lambda function
  TermProjectPreviosMonthlyExpenses:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: "Term-Project-Previous-Month-Expense"
      Handler: "index.handler"
      Role: YourRoleArn
      Runtime: "nodejs20.x"
      Timeout: 20
      Code:
        ZipFile: | 
          const { DynamoDBDocument } = require("@aws-sdk/lib-dynamodb");
          const { DynamoDB } = require("@aws-sdk/client-dynamodb");

          const dynamoDB = DynamoDBDocument.from(new DynamoDB({ region: "us-east-1" }));

          const tableName = "Term-Project-Expense-Table";

          exports.handler = async (event) => {
            try {
              const body = JSON.parse(event.body);
              console.log(body);
              const email = body.useremail;
              console.log(email);
              const userDetails = await getUserDetails(email);

              if (!userDetails) {
                return buildResponse(400, "You have not added any expense");
              }
              const expenseList = userDetails.expenses;

              const result = [];
              for (const monthKey in expenseList) {
                const expenses = expenseList[monthKey];
                let total = 0;
                for (let i = 0; i < expenses.length; i++) {
                  const expense = expenses[i];
                  total += parseFloat(expense.amount);
                }
                result.push({
                  month: monthKey,
                  expense: total
                });
              }

              return buildResponse(200, result);
            } catch (error) {
              console.error("Error sending reports:", error);
              return buildResponse(500, "Server error while sending reports.");
            }
          };

          const getUserDetails = async (email) => {
            const params = {
              TableName: tableName,
              Key: {
                useremail: email
              }
            };

            try {
              const response = await dynamoDB.get(params);
              console.log(response);
              return response.Item;
            } catch (error) {
              console.log(error);
              throw new Error("Error getting User details");
            }
          };

          const buildResponse = (statusCode, message) => {
            return {
              statusCode: statusCode,
              headers: {
                "Access-Control-Allow-Origin": "*",
                "Content-Type": "application/json"
              },
              body: JSON.stringify(message)
            };
          };

# Send Monthly Reports Lambda function
  TermProjectSendReports:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: "Term-Project-Send-Monthly-Reports"
      Handler: "index.handler"
      Role: YourRoleArn
      Runtime: "nodejs20.x"
      Timeout: 20
      Environment:
        Variables:
          SNS_ARN: !Ref TermProjectNotificationTopic
      Code:
        ZipFile: | 
          const { DynamoDBDocument } = require("@aws-sdk/lib-dynamodb");
          const { DynamoDB } = require("@aws-sdk/client-dynamodb");
          const { SNSClient, PublishCommand } = require("@aws-sdk/client-sns");

          const dynamoDB = DynamoDBDocument.from(new DynamoDB({ region: "us-east-1" }));
          const sns = new SNSClient({ region: "us-east-1" });

          const tableName = "Term-Project-Expense-Table";

          exports.handler = async (event) => {
            try {
              const users = await getAllUsers();

              const currentMonth = new Date().toISOString().slice(0, 7);
              const promises = users.map(async (user) => {
                const { total, highestExpense, allExpenses } =
                  await calculateTotalForMonth(user.expenses, currentMonth);
                await sendReportEmail(
                  user.useremail,
                  total,
                  highestExpense,
                  allExpenses,
                  currentMonth
                );
              });

              await Promise.all(promises);
              return buildResponse(200, "Reports sent successfully.");
            } catch (error) {
              console.error("Error sending reports:", error);
              return buildResponse(500, "Server error while sending reports.");
            }
          };

          const getAllUsers = async () => {
            const params = {
              TableName: tableName
            };

            const scanResults = [];
            let items;
            let exclusiveStartKey;

            while (true) {
              items = await dynamoDB.scan(params);
              items.Items.forEach((item) => scanResults.push(item));
              params.ExclusiveStartKey = items.LastEvaluatedKey;

              if (!items.LastEvaluatedKey) {
                break;
              }
            }

            return scanResults;
          };

          const calculateTotalForMonth = async (expenses, monthKey) => {
            let total = 0;
            let highestExpense = { expenseName: "", amount: 0 };
            let allExpenses = [];

            if (expenses[monthKey]) {
              expenses[monthKey].forEach((expense) => {
                const amount = parseFloat(expense.amount);
                total += amount;
                allExpenses.push(expense);
                if (amount > highestExpense.amount) {
                  highestExpense = expense;
                }
              });
            }

            return { total, highestExpense, allExpenses };
          };

          const sendReportEmail = async (
            email,
            total,
            highestExpense,
            allExpenses,
            monthKey
          ) => {
            try {
              const subject = "Your Monthly Expense Report";
              let expenseList = allExpenses
                .map((exp) => `${exp.expenseName}: ${exp.amount}`)
                .join("\n");
              const message = `You have spent a total amount of ${total} for the month of ${monthKey} until now. Your highest expense was ${highestExpense.amount} for ${highestExpense.expenseName}.\n\nHere is the list of all your expenses for this month:\n${expenseList}`;
              await sns.send(
                new PublishCommand({
                  Message: message,
                  Subject: subject,
                  TargetArn: process.env.SNS_ARN,
                  MessageAttributes: {
                    email: {
                      DataType: "String",
                      StringValue: email
                    }
                  }
                })
              );
            } catch (error) {
              console.log(error.message);
              throw new Error("Error Sending Mail");
            }
          };

          const buildResponse = (statusCode, message) => {
            return {
              statusCode: statusCode,
              headers: {
                "Access-Control-Allow-Origin": "*",
                "Content-Type": "application/json"
              },
              body: JSON.stringify({ message })
            };
          };

# DynamoDB Table for User 
  TermProjectApplicationUsersTable:
    Type: "AWS::DynamoDB::Table"
    Properties:
      TableName: "Term-Project-Application-Users"
      AttributeDefinitions:
        - AttributeName: "useremail"
          AttributeType: "S"
      KeySchema:
        - AttributeName: "useremail"
          KeyType: "HASH"
      BillingMode: "PAY_PER_REQUEST"

# DynamoDB Table for Reset Password Code
  TermProjectResetPasswordCode:
    Type: "AWS::DynamoDB::Table"
    Properties:
      TableName: "Term-Project-Reset-Password-Code"
      AttributeDefinitions:
        - AttributeName: "useremail"
          AttributeType: "S"
      KeySchema:
        - AttributeName: "useremail"
          KeyType: "HASH"
      BillingMode: "PAY_PER_REQUEST"

# DynamoDB Table for Expense details
  TermProjectExpenseTable:
    Type: "AWS::DynamoDB::Table"
    Properties:
      TableName: "Term-Project-Expense-Table"
      AttributeDefinitions:
        - AttributeName: "useremail"
          AttributeType: "S"
      KeySchema:
        - AttributeName: "useremail"
          KeyType: "HASH"
      BillingMode: "PAY_PER_REQUEST"

# S3 Bucket for uploading images
  TermProjectS3Bucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: "term-project-expense-tracker-bucket"
      CorsConfiguration:
        CorsRules:
          - AllowedOrigins:
              - "*"
            AllowedMethods:
              - GET
            AllowedHeaders:
              - "*"
            MaxAge: 3000
      PublicAccessBlockConfiguration:
        BlockPublicAcls: false
        BlockPublicPolicy: false
        IgnorePublicAcls: false
        RestrictPublicBuckets: false

# Bucket Policy for allowing public access   
  TermProjectS3BucketPolicy:
    Type: 'AWS::S3::BucketPolicy'
    Properties:
      Bucket: !Ref TermProjectS3Bucket
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal: '*'
            Action: 's3:GetObject'
            Resource: !Sub 'arn:aws:s3:::${TermProjectS3Bucket}/*'

# EventBridge Scheduler Event for Sending Monthly Reports ( CRON JOB ) 
  TermProjectSendReportsEvent:
    Type: AWS::Events::Rule
    Properties:
      Name: "Term-Project-Send-Monthly-Reports"
      ScheduleExpression: cron(40 14 13 * ? *)
      State: ENABLED
      Targets:
        - Arn: !GetAtt TermProjectSendReports.Arn
          Id: "MyLambdaFunctionTarget"

# REST API Endpoint
  TermProjectEndpoint:
    Type: AWS::ApiGateway::RestApi
    Properties:
      Description: "Endpoint for Term Project"
      Name: TermProjectAPI

# REST Resource for Register User
  RegisterResource:
    Type: "AWS::ApiGateway::Resource"
    Properties:
      ParentId:
        Fn::GetAtt:
          - TermProjectEndpoint
          - RootResourceId
      PathPart: "register"
      RestApiId:
        Ref: TermProjectEndpoint

# REST Resource for Login
  LoginResource:
    Type: "AWS::ApiGateway::Resource"
    Properties:
      ParentId:
        Fn::GetAtt:
          - TermProjectEndpoint
          - RootResourceId
      PathPart: "login"
      RestApiId:
        Ref: TermProjectEndpoint

# REST Resource for Adding Expense
  AddExpenseResource:
    Type: "AWS::ApiGateway::Resource"
    Properties:
      ParentId:
        Fn::GetAtt:
          - TermProjectEndpoint
          - RootResourceId
      PathPart: "add-expense"
      RestApiId:
        Ref: TermProjectEndpoint

# REST Resource for Getting Current Month Expense details
  GetCurrentMonthResource:
    Type: "AWS::ApiGateway::Resource"
    Properties:
      ParentId:
        Fn::GetAtt:
          - TermProjectEndpoint
          - RootResourceId
      PathPart: "get-current-expense"
      RestApiId:
        Ref: TermProjectEndpoint

# REST Resource for Getting All Month Expense details
  GetAllExpenseResource:
    Type: "AWS::ApiGateway::Resource"
    Properties:
      ParentId:
        Fn::GetAtt:
          - TermProjectEndpoint
          - RootResourceId
      PathPart: "get-all-expense"
      RestApiId:
        Ref: TermProjectEndpoint

# REST Resource for Resetting Password
  ResetPasswordResource:
    Type: "AWS::ApiGateway::Resource"
    Properties:
      ParentId:
        Fn::GetAtt:
          - TermProjectEndpoint
          - RootResourceId
      PathPart: "reset-password"
      RestApiId:
        Ref: TermProjectEndpoint

# REST Resource for Changing Password
  ChangePasswordResource:
    Type: "AWS::ApiGateway::Resource"
    Properties:
      ParentId:
        Fn::GetAtt:
          - TermProjectEndpoint
          - RootResourceId
      PathPart: "change-password"
      RestApiId:
        Ref: TermProjectEndpoint

# Register User Lambda Integration with Register User REST Resource
  RegisterUserLambdaIntegration:
    Type: "AWS::ApiGateway::Method"
    Properties:
      AuthorizationType: "NONE"
      HttpMethod: "POST"
      ResourceId:
        Ref: RegisterResource
      RestApiId:
        Ref: TermProjectEndpoint
      Integration:
        IntegrationHttpMethod: "POST"
        Type: "AWS_PROXY"
        Uri:
          Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${TermProjectRegisterUser.Arn}/invocations
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,x-amz-security-token'"
              method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Origin: true

# Login User Lambda Integration with Login Lambda REST Resource
  LoginLambdaIntegration:
    Type: "AWS::ApiGateway::Method"
    Properties:
      AuthorizationType: "NONE"
      HttpMethod: "POST"
      ResourceId:
        Ref: LoginResource
      RestApiId:
        Ref: TermProjectEndpoint
      Integration:
        IntegrationHttpMethod: "POST"
        Type: "AWS_PROXY"
        Uri:
          Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${TermProjectLoginUser.Arn}/invocations
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,x-amz-security-token'"
              method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Origin: true

# Reset Password Lambda Integration with Reset Password Resource
  ResetPasswordLambdaIntegration:
    Type: "AWS::ApiGateway::Method"
    Properties:
      AuthorizationType: "NONE"
      HttpMethod: "POST"
      ResourceId:
        Ref: ResetPasswordResource
      RestApiId:
        Ref: TermProjectEndpoint
      Integration:
        IntegrationHttpMethod: "POST"
        Type: "AWS_PROXY"
        Uri:
          Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${TermProjectResetPassword.Arn}/invocations
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,x-amz-security-token'"
              method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Origin: true

# Change Password Lambda Integration with Change Password Resource
  ChangePasswordLambdaIntegration:
    Type: "AWS::ApiGateway::Method"
    Properties:
      AuthorizationType: "NONE"
      HttpMethod: "POST"
      ResourceId:
        Ref: ChangePasswordResource
      RestApiId:
        Ref: TermProjectEndpoint
      Integration:
        IntegrationHttpMethod: "POST"
        Type: "AWS_PROXY"
        Uri:
          Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${TermProjectChangePassword.Arn}/invocations
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,x-amz-security-token'"
              method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Origin: true

# Add Expense Lambda Integration with Add Expense Resource
  AddExpenseLambdaIntegration:
    Type: "AWS::ApiGateway::Method"
    Properties:
      AuthorizationType: "NONE"
      HttpMethod: "POST"
      ResourceId:
        Ref: AddExpenseResource
      RestApiId:
        Ref: TermProjectEndpoint
      Integration:
        IntegrationHttpMethod: "POST"
        Type: "AWS_PROXY"
        Uri:
          Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${TermProjectAddExpense.Arn}/invocations
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,x-amz-security-token'"
              method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Origin: true

# Get Current Month Expense Details Lambda Integration with Get Current Month Expense Resource
  GetCurrentMonthExpenseLambdaIntegration:
    Type: "AWS::ApiGateway::Method"
    Properties:
      AuthorizationType: "NONE"
      HttpMethod: "POST"
      ResourceId:
        Ref: GetCurrentMonthResource
      RestApiId:
        Ref: TermProjectEndpoint
      Integration:
        IntegrationHttpMethod: "POST"
        Type: "AWS_PROXY"
        Uri:
          Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${TermProjectGetCurrentMonthExpense.Arn}/invocations
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,x-amz-security-token'"
              method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Origin: true

# Get All Month Expense Details Lambda Integration with Get All Month Expense Resource
  GetAllExpenseLambdaIntegration:
    Type: "AWS::ApiGateway::Method"
    Properties:
      AuthorizationType: "NONE"
      HttpMethod: "POST"
      ResourceId:
        Ref: GetAllExpenseResource
      RestApiId:
        Ref: TermProjectEndpoint
      Integration:
        IntegrationHttpMethod: "POST"
        Type: "AWS_PROXY"
        Uri:
          Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${TermProjectPreviosMonthlyExpenses.Arn}/invocations
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,x-amz-security-token'"
              method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Origin: true

# Preflight Request check for Register User
  RegisterUserLambdaIntegrationOptions:
    Type: "AWS::ApiGateway::Method"
    Properties:
      AuthorizationType: "NONE"
      HttpMethod: "OPTIONS"
      ResourceId:
        Ref: RegisterResource
      RestApiId:
        Ref: TermProjectEndpoint
      Integration:
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,x-amz-security-token'"
              method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
        RequestTemplates:
          application/json: '{"statusCode": 200}'
        Type: MOCK
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Origin: true

# Preflight Request check for Login 
  LoginLambdaIntegrationOptions:
    Type: "AWS::ApiGateway::Method"
    Properties:
      AuthorizationType: "NONE"
      HttpMethod: "OPTIONS"
      ResourceId:
        Ref: LoginResource
      RestApiId:
        Ref: TermProjectEndpoint
      Integration:
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,x-amz-security-token'"
              method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
        RequestTemplates:
          application/json: '{"statusCode": 200}'
        Type: MOCK
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Origin: true

# Preflight Request check for Reset Password
  ResetPasswordLambdaIntegrationOptions:
    Type: "AWS::ApiGateway::Method"
    Properties:
      AuthorizationType: "NONE"
      HttpMethod: "OPTIONS"
      ResourceId:
        Ref: ResetPasswordResource
      RestApiId:
        Ref: TermProjectEndpoint
      Integration:
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,x-amz-security-token'"
              method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
        RequestTemplates:
          application/json: '{"statusCode": 200}'
        Type: MOCK
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Origin: true

# Preflight Request check for Change Password
  ChangePasswordLambdaIntegrationOptions:
    Type: "AWS::ApiGateway::Method"
    Properties:
      AuthorizationType: "NONE"
      HttpMethod: "OPTIONS"
      ResourceId:
        Ref: ChangePasswordResource
      RestApiId:
        Ref: TermProjectEndpoint
      Integration:
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,x-amz-security-token'"
              method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
        RequestTemplates:
          application/json: '{"statusCode": 200}'
        Type: MOCK
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Origin: true

# Preflight Request check for Adding Expense
  AddExpenseLambdaIntegrationOptions:
    Type: "AWS::ApiGateway::Method"
    Properties:
      AuthorizationType: "NONE"
      HttpMethod: "OPTIONS"
      ResourceId:
        Ref: AddExpenseResource
      RestApiId:
        Ref: TermProjectEndpoint
      Integration:
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,x-amz-security-token'"
              method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
        RequestTemplates:
          application/json: '{"statusCode": 200}'
        Type: MOCK
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Origin: true

# Preflight Request check for Get All Expense
  GetAllExpenseLambdaIntegrationOptions:
    Type: "AWS::ApiGateway::Method"
    Properties:
      AuthorizationType: "NONE"
      HttpMethod: "OPTIONS"
      ResourceId:
        Ref: GetAllExpenseResource
      RestApiId:
        Ref: TermProjectEndpoint
      Integration:
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,x-amz-security-token'"
              method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
        RequestTemplates:
          application/json: '{"statusCode": 200}'
        Type: MOCK
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Origin: true

# Preflight Request check for Get Current Month Expense
  GetCurrentMonthExpenseLambdaIntegrationOptions:
    Type: "AWS::ApiGateway::Method"
    Properties:
      AuthorizationType: "NONE"
      HttpMethod: "OPTIONS"
      ResourceId:
        Ref: GetCurrentMonthResource
      RestApiId:
        Ref: TermProjectEndpoint
      Integration:
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,x-amz-security-token'"
              method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
        RequestTemplates:
          application/json: '{"statusCode": 200}'
        Type: MOCK
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Origin: true

# REST API Endpoint Deployment
  ApiGatewayDeployment:
    Type: "AWS::ApiGateway::Deployment"
    Properties:
      RestApiId:
        Ref: TermProjectEndpoint
      StageName: "prod"
    DependsOn:
      - RegisterUserLambdaIntegration
      - LoginLambdaIntegration
      - ResetPasswordLambdaIntegration
      - ChangePasswordLambdaIntegration
      - AddExpenseLambdaIntegration
      - GetAllExpenseLambdaIntegration
      - GetCurrentMonthExpenseLambdaIntegration
      - RegisterUserLambdaIntegrationOptions
      - LoginLambdaIntegrationOptions
      - ResetPasswordLambdaIntegrationOptions
      - ChangePasswordLambdaIntegrationOptions
      - AddExpenseLambdaIntegrationOptions
      - GetAllExpenseLambdaIntegrationOptions
      - GetCurrentMonthExpenseLambdaIntegrationOptions

# Register User Lambda Invokation Permission
  LambdaPermissionForRegister:
    Type: "AWS::Lambda::Permission"
    Properties:
      Action: "lambda:InvokeFunction"
      FunctionName:
        Ref: TermProjectRegisterUser
      Principal: "apigateway.amazonaws.com"
      SourceArn:
        Fn::Sub: arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${TermProjectEndpoint}/*/POST/register

# Login Lambda Invokation Permission
  LambdaPermissionForLogin:
    Type: "AWS::Lambda::Permission"
    Properties:
      Action: "lambda:InvokeFunction"
      FunctionName:
        Ref: TermProjectLoginUser
      Principal: "apigateway.amazonaws.com"
      SourceArn:
        Fn::Sub: arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${TermProjectEndpoint}/*/POST/login

# Reset Password Lambda Invokation Permission
  LambdaPermissionForResetPassword:
    Type: "AWS::Lambda::Permission"
    Properties:
      Action: "lambda:InvokeFunction"
      FunctionName:
        Ref: TermProjectResetPassword
      Principal: "apigateway.amazonaws.com"
      SourceArn:
        Fn::Sub: arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${TermProjectEndpoint}/*/POST/reset-password

# Change Password Lambda Invokation Permission
  LambdaPermissionForChangePassword:
    Type: "AWS::Lambda::Permission"
    Properties:
      Action: "lambda:InvokeFunction"
      FunctionName:
        Ref: TermProjectChangePassword
      Principal: "apigateway.amazonaws.com"
      SourceArn:
        Fn::Sub: arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${TermProjectEndpoint}/*/POST/change-password

# Add Expense Lambda Invokation Permission
  LambdaPermissionForAddExpense:
    Type: "AWS::Lambda::Permission"
    Properties:
      Action: "lambda:InvokeFunction"
      FunctionName:
        Ref: TermProjectAddExpense
      Principal: "apigateway.amazonaws.com"
      SourceArn:
        Fn::Sub: arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${TermProjectEndpoint}/*/POST/add-expense

# Get Current Month Lambda Invokation Permission
  LambdaPermissionForGetCurrentMonthExpense:
    Type: "AWS::Lambda::Permission"
    Properties:
      Action: "lambda:InvokeFunction"
      FunctionName:
        Ref: TermProjectGetCurrentMonthExpense
      Principal: "apigateway.amazonaws.com"
      SourceArn:
        Fn::Sub: arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${TermProjectEndpoint}/*/POST/get-current-expense

# Get All Expense Lambda Invokation Permission
  LambdaPermissionForGetAllExpense:
    Type: "AWS::Lambda::Permission"
    Properties:
      Action: "lambda:InvokeFunction"
      FunctionName:
        Ref: TermProjectPreviosMonthlyExpenses
      Principal: "apigateway.amazonaws.com"
      SourceArn:
        Fn::Sub: arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${TermProjectEndpoint}/*/POST/get-all-expense

# Send Monthly Report Lambda Invokation Permission
  LambdaPermissionForSendMonthlyReports:
    Type: "AWS::Lambda::Permission"
    Properties:
      Action: "lambda:InvokeFunction"
      FunctionName:
        Ref: TermProjectSendReports
      Principal: "events.amazonaws.com"
      SourceArn: !GetAtt TermProjectSendReportsEvent.Arn

# EC2 Instance for hosting frontend
  TermProjectEC2Instance:
    Type: "AWS::EC2::Instance"
    Properties:
      InstanceType: t2.micro
      ImageId: ami-0ba9883b710b05ac6
      KeyName: ec2-key
      SecurityGroups:
        - !Ref InstanceSecurityGroup
      UserData:
        Fn::Base64: !Sub |
          #!/bin/bash -xe
          yum update -y
          yum install -y docker
          service docker start
          usermod -a -G docker ec2-user

# Security Group Policy for EC2
  InstanceSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Enable SSH and TCP/3000 access
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 22
          ToPort: 22
          CidrIp: 0.0.0.0/0
        - IpProtocol: tcp
          FromPort: 3000
          ToPort: 3000
          CidrIp: 0.0.0.0/0

Outputs:
  TermProjectRESTEndpoint:
    Description: "API Gateway endpoint URL"
    Value:
      Fn::Sub: https://${TermProjectEndpoint}.execute-api.${AWS::Region}.amazonaws.com/prod
  SNSNotificationTopicARN:
    Description: "SNS Topic ARN for Notifications"
    Value:
      Ref: TermProjectNotificationTopic
  RegisterLambdaARN:
    Description: "Lambda Function ARN for Registering User"
    Value: !GetAtt TermProjectRegisterUser.Arn
  LoginLambdaARN:
    Description: "Lambda Function ARN for Login"
    Value: !GetAtt TermProjectLoginUser.Arn
  ResetPasswordLambdaARN:
    Description: "Lambda Function ARN for Resetting Password"
    Value: !GetAtt TermProjectResetPassword.Arn
  ChangePasswordLambdaARN:
    Description: "Lambda Function ARN for Changing Password"
    Value: !GetAtt TermProjectChangePassword.Arn
  AddExpenseLambdaARN:
    Description: "Lambda Function ARN for Adding Expense"
    Value: !GetAtt TermProjectAddExpense.Arn
  GetAllExpenseLambdaARN:
    Description: "Lambda Function ARN for Getting All Expenses"
    Value: !GetAtt TermProjectPreviosMonthlyExpenses.Arn
  GetCurrentMonthExpenseLambdaARN:
    Description: "Lambda Function ARN for Getting Current Month Expenses"
    Value: !GetAtt TermProjectGetCurrentMonthExpense.Arn
  SendReportLambdaARN:
    Description: "Lambda Function ARN for Sending Weekly Reports"
    Value: !GetAtt TermProjectSendReports.Arn